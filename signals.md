
## 1. Can you explain the concept of signals in programming? How are they used in Unix
like operating systems? 

Signals are asynchronous notifications sent to a process to inform it of events such as interrupts or exceptions. In Unix-like systems, they are used to handle events like `Ctrl+C` (SIGINT) or illegal operations without continuous polling.

## 2. What are software interrupts and hardware interrupts and mention potential issues 
when dealing with them?

Hardware interrupts come from external devices like keyboards or timers, while software interrupts are generated by programs or system calls. Problems like race conditions, lost interrupts, or priority inversion may occur if not handled properly.

## 3. What is synchronous signal and asynchronous signal and how the process can be used for both?

Synchronous signals occur due to a processâ€™s own actions (like division by zero), whereas asynchronous signals come from external sources such as other processes. A process can use both by registering handlers for external signals and letting the kernel deliver internal ones.

## 4. Who is responsible for generating signals?

Signals can be generated by the kernel (for errors like segmentation faults), other processes (using the `kill()` system call), or hardware/terminal input (like pressing `Ctrl+C`).

## 5. What is signal handler?
   
A signal handler is a user-defined function that executes when a signal is received, allowing a process to take custom actions instead of following the default behavior like termination or ignoring the signal.

## 6. Which system call is used to send a signal to the process?
   
The `kill(pid, signal)` system call is used to send signals to a specific process, while `raise(signal)` can send a signal to the calling process itself.

## 7. Write a program to send a signal to itself (same process)?

A process can send a signal to itself using the `raise()` function, for example:

```c
raise(SIGUSR1);
```

This sends the SIGUSR1 signal to the same process.

## 8. Explain the default action associated with the SIGKILL signal?
   
The default action of `SIGKILL` is to immediately and unconditionally terminate a process; it cannot be caught, blocked, or ignored by the process.

## 9. How does a process handle a signal while it is executing in kernel mode?
    
When a process is in kernel mode, signals are held pending and delivered only after returning to user mode to ensure kernel operations are not interrupted.

## 10. Describe the behaviour of a process when it receives a SIGSEGV signal?

When a process receives a `SIGSEGV` signal due to invalid memory access, it terminates by default and may produce a core dump unless a custom handler is defined.
## 2. Implement a C program to send a custom signal to another process. 
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int sig) {
    printf("Received custom signal: %d (SIGUSR1)\n", sig);
    fflush(stdout); // ensure output appears immediately
}

int main() {
    signal(SIGUSR1, handler);
    printf("Waiting for SIGUSR1... (PID: %d)\n", getpid());
    fflush(stdout);

    while (1)
        pause();  // wait until a signal arrives

    return 0;
}
```
## 3. Create a C program to ignore the SIGCHLD signal temporarily. 
```c
#include<stdio.h>
#include<string.h>
#include<signal.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/wait.h>
int main()
{
        int pid;
        signal(SIGCHLD,SIG_IGN);
        pid=fork();
        if(pid==0)
        {
                printf("child process id is %d",getpid());
                exit(1);
        }
        printf("parent pid is %d",getpid());
        signal(SIGCHLD,SIG_DFL);
        sleep(2);
        wait(NULL);
}
```
## 4. Write a program to block the SIGTERM signal using sigprocmask().
```c
#include<stdio.h>
#include<signal.h>
#include<stdlib.h>
#include<unistd.h>
int main()
{
        sigset_t set;
        sigemptyset(&set);
        sigaddset(&set,SIGTERM);
        sigprocmask(SIG_BLOCK,&set,NULL);
        sleep(10);
        printf("pid is %d\n",getpid());
        sigprocmask(SIG_UNBLOCK,&set,NULL);
        sleep(2);
}
```
## 5. Implement a C program to handle the SIGALRM signal using sigaction().
```c
#include<stdio.h>
#include<string.h>
#include<unistd.h>
#include<stdlib.h>
#include<signal.h>
void signal_handler(int sig)
{
        printf("Waiting for SIGTERM signal... (PID: %d)\n", getpid());
        exit(0);
}
int main()
{
        signal(SIGTERM,signal_handler);
        printf("signal is terminate id is %d\n",getpid());
        while(1)
        {
                sleep(1);
        }
}
finally another terminal i have to give kill -TERM pid number
```
## 7. Implement a program to handle the SIGSEGV signal (segmentation fault). 
```c
#include<stdio.h>
#include<stdlib.h>
#include<signal.h>
#include<unistd.h>
void sgnl_hand()
{
        printf("segmentation default occure in pid %d",getpid());
        exit(0);
}
int main()
{
        signal(SIGSEGV,sgnl_hand);
        printf("occuring of segmentation fault\n");
        sleep(1);
        int *ptr=NULL;
        *ptr=10;
}
```
## 8. Create a program to handle the SIGILL signal (illegal instruction).
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<signal.h>
void sigill_handler()
{
        printf("illegal instruction has been detected\n");
        exit(1);
}
int main()
{
        signal(SIGILL,sigill_handler);
        printf("signal has been sent\n");
        sleep(3);
        raise(SIGILL);
}
```
## 9. Write a program to handle the SIGABRT signal (abort). 
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<signal.h>
void abort_handler()
{
        printf("aborting  the signal of pid %d\n",getpid());
}

int main()
{
        signal(SIGABRT,abort_handler);
        sleep(2);
        abort();
        printf("aborted\n");
}
```
## 10. Implement a C program to handle the SIGQUIT signal.
```c
#include<stdio.h>
#include<stdlib.h>
#include<signal.h>
#include<unistd.h>
void quit_handler(int sig)
{
        printf("press ctrl+ backslash to quit this process %d\n",getpid());
        exit(0);
}
int main()
{
        signal(SIGQUIT,quit_handler);
        while(1)
        {
                sleep(1);
        }
}
```
## 14. Write a program to handle the SIGWINCH signal (window size change).
```c
#include <stdio.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <unistd.h>

void handle_sigwinch(int sig) {
    struct winsize w;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
    printf("\nWindow size changed: %d rows, %d columns\n", w.ws_row, w.ws_col);
    fflush(stdout);
}
int main() {
    struct sigaction sa;
    sa.sa_handler = handle_sigwinch;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGWINCH, &sa, NULL);
    printf("Resize the terminal window to trigger SIGWINCH...\n");
    fflush(stdout);
    while (1)
        pause();
}
```
## 12. Write a program to handle the SIGTSTP signal (terminal stop). 
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<signal.h>
void stop_handler(int sig)
{
        printf("\nPress Ctrl+Z to stop the process %d\n",getpid());
        exit(0);
}
int main()
{
        signal(SIGTSTP,stop_handler);
        printf("To stop the signal\n");
        while(1)
        {
                sleep(1);
        }
}
```
## 13. Write a program to handle the SIGVTALRM signal (virtual timer expired).
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<signal.h>
#include<sys/time.h>
void vt_handler(int sig)
{
        printf("\nSIGVTALRM received: virtual timer expired\n");
        exit(0);
}
int main()
{
        struct itimerval timer;
        signal(SIGVTALRM,vt_handler);
        timer.it_value.tv_sec=3;
        timer.it_value.tv_usec=0;
        timer.it_interval.tv_sec=0;
        timer.it_interval.tv_usec=0;
        setitimer(ITIMER_VIRTUAL,&timer,NULL);
        printf("Virtual timer set for 3 seconds\n");
        while(1);
}
```
## 16. Create a program to handle the SIGPWR signal (power failure restart).
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<signal.h>
void pwr_handler(int sig)
{
        printf("\nSIGPWR received: Power failure or restart event detected\n");
}
int main()
{
        signal(SIGPWR,pwr_handler);
        printf("Waiting for SIGPWR signal..%d.\n",getpid());
        while(1)
        {
                sleep(1);
        }
}
```
## 18. Write a program to handle the SIGSYS signal (bad system call).
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<signal.h>
void sys_handler(int sig)
{
        printf("\nSIGSYS received: bad system call\n");
        exit(0);
}
int main()
{
        signal(SIGSYS,sys_handler);
        printf("Waiting for SIGSYS signal...\n");
        while(1)
        {
                sleep(1);
        }
}
```
## 19. Write a C program to handle the SIGIO signal (I/O is possible on a descriptor).
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<signal.h>
#include<fcntl.h>
void io_handler(int sig)
{
        printf("\nSIGIO received: I/O is possible on descriptor\n");
}
int main()
{
        int fd=open("/dev/tty",O_RDONLY);
        fcntl(fd,F_SETOWN,getpid());
        int flags=fcntl(fd,F_GETFL);
        fcntl(fd,F_SETFL,flags|O_ASYNC);
        signal(SIGIO,io_handler);
        printf("Type something to trigger SIGIO...\n");
        while(1)
        {
                sleep(1);
        }
}
```
20. Implement a C program to handle the SIGINFO signal (status request from keyboard).
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<signal.h>
void info_handler(int sig)
{
        printf("\nSIGINFO received: status request from keyboard\n");
}
int main()
{
        signal(SIGINFO,info_handler);
        printf("Press Ctrl+T to trigger SIGINFO\n");
        while(1)
        {
                sleep(1);
        }
}
```
## 28. Write a program to demonstrate how to block signals using sigprocmask(). 
```c
#include<stdio.h>
#include<signal.h>
#include<stdlib.h>
#include<unistd.h>
void handler(int sig)
{
        printf("handler is producing after 10 seconds\n");
}
int main()
{
        sigset_t set;
        signal(SIGINT,handler);
        sigemptyset(&set);
        sigaddset(&set,SIGINT);
        sigprocmask(SIG_BLOCK,&set,NULL);
        sleep(10);
        sigprocmask(SIG_UNBLOCK,&set,NULL);
}
```
## 29  Write a program to implement a timer using signals. 
```c
#include<stdio.h>
#include<unistd.h>
#include<signal.h>
void handler(int sig)
{
        printf("the alaram time is set to %d",sig);
}
int main()
{
        signal(SIGALRM,handler);
        printf("alaram is set to 5 sec");
        alarm(5);
        while(1)
        {
                printf("waiting\n");
                sleep(1);
        }
}
```
## 31. Why we use raise system call explain it programmatically 
```c
#include<stdio.h>
#include<signal.h>
#include<unistd.h>
void handler(int sig)
{
        printf("the signal has beem raised\n");
}
int main()
{
        signal(SIGINT,handler);
        printf("raising the system calli%d\n",getpid());
        raise(SIGINT);
}
```
## 32.Write a program to handle SIGALRM (alarm clock) signal for implementing a timeout mechanism in system programming.
```c
#include<stdio.h>
#include<signal.h>
#include<unistd.h>
void tiout_handleer()
{
        printf("after the time out of alarm\n");
}
int main()
{
        signal(SIGALRM,tiout_handleer);
        alarm(5);
        char str[100];
        fgets(str,sizeof(str),stdin);
        printf("\n%s\n",str);
        while(1)
        {
                sleep(1);
        }
}
```
## 44. Write a program on watch dog timer and it explain its working 
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<signal.h>
void watch_dog(int sig)
{
        printf("the alarm will now out\n");
}
int main()
{
        signal(SIGALRM,watch_dog);
        alarm(5);
        int count=0;
        while(1)
        {
               printf("sys running %d\n",count+1);
                count++;
                if(count%2==0)
                {
                        printf("reporting timer working sucesssfully\n");
                }
                sleep(1);
                if(count==4)
                {
                        printf("reporting timer not working\n");
                        while(1)
                        {
                                sleep(1);
                        }
                }
        }

}
```
## 46. Write a program to demonstrate the use of sigaction() for handling signals.
```c
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<signal.h>
void handler(int sig)
{
        printf("sig action \n");
}
int main()
{
        struct sigaction sa;
        sa.sa_handler=handler;
        sa.sa_flags=0;
        sigemptyset(&sa.sa_mask);
        sigaction(SIGINT,&sa,NULL);
        while(1)
        {
                sleep(1);
        }
}
```
## //49. Write a program to demonstrate signal handling in a multithreaded environment. 
```c
#include<stdio.h>
#include<stdlib.h>
#include<signal.h>
#include<pthread.h>
#include<unistd.h>
void handler(int sig)
{
        printf("signal %d ofid have the pthreadis %lu\n",sig,pthread_self());
        exit(0);
}
void *create(void *arg)
{
        int id=*(int *)arg;
        printf("pthread %lu of pid\n",pthread_self());
        sleep(2);
}
int main()
{
        struct sigaction sa;
        sa.sa_handler=handler;
        sa.sa_flags=0;
        sigemptyset(&sa.sa_mask);
        sigaction(SIGINT,&sa,NULL);
        pthread_t p1,p2;
        int id1=1;
        int id2=2;
        pthread_create(&p1,NULL,create,&id1);
        pthread_create(&p2,NULL,create,&id2);
        pthread_join(p1,NULL);
        pthread_join(p2,NULL);
        while(1)
        {
                sleep(1);
        }
}
```
## 52. Write a program to demonstrate handling multiple signals using sigaction(). 
```c
#include<stdio.h>
#include<signal.h>
#include<stdlib.h>
#include<unistd.h>
void handler(int sig)
{
        switch(sig)
        {
                case SIGINT:
                        printf("SIGINT id number is %d\n",sig);
                        break;
                case SIGTERM:
                        printf("SIGTERM,id number is %d\n",sig);
                        break;
                case SIGUSR1:
                        printf("SIGUSR1,id number is %d\n",sig);
                        break;
                case SIGUSR2:
                        printf("SIGUSR2,id number is %d\n",sig);
                        break;
                default:
                        printf("invalid\n");
                        break;
        }
}

int main()
{
        struct sigaction sa;
        sa.sa_handler=handler;
        sa.sa_flags=0;
        sigemptyset(&sa.sa_mask);
        sigaction(SIGINT,&sa,NULL);
        sigaction(SIGTERM,&sa,NULL);
        sigaction(SIGUSR1,&sa,NULL);
        sigaction(SIGUSR2,&sa,NULL);
        while(1)
        {
                pause();
        }
}
```
